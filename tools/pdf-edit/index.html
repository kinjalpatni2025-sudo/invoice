<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Advanced PDF Editor — Smarttool Hub (Full)</title>
<meta name="description" content="Advanced browser PDF editor with IndexedDB persistence, rich-text, draggable/resize/rotate text boxes, image crop/resize/rotate, page reorder, export/import JSON and ZIP download.">
<link rel="icon" type="image/png" href="https://img.icons8.com/fluency/48/toolbox.png">

<!-- Libraries -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

<style>
  :root{--bg:#071124;--card:#0f1724;--muted:#9aa8bf;--accent:#60a5fa}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef8}
  header{position:sticky;top:0;z-index:2000;display:flex;align-items:center;justify-content:space-between;padding:12px 18px;background:linear-gradient(90deg,#2563eb,#06b6d4);box-shadow:0 4px 14px rgba(0,0,0,0.4)}
  header .left{display:flex;gap:12px;align-items:center}
  header img{width:40px;height:40px;border-radius:8px}
  header h1{margin:0;font-size:18px}
  .container{max-width:1200px;margin:18px auto;padding:12px}
  .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:10px;cursor:pointer}
  .btn.primary{background:linear-gradient(90deg,#3b82f6,#06b6d4);border:none;color:#041124}
  .small{padding:6px 8px;font-size:13px}
  .canvas-wrap{position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.04);margin-top:12px}
  canvas{display:block;width:100%}
  #annotLayer{position:absolute;left:0;top:0;pointer-events:none}
  .text-box{position:absolute;min-width:60px;padding:6px 8px;background:rgba(0,0,0,0.45);border:1px dashed rgba(255,255,255,0.08);color:#fff;border-radius:6px;cursor:move;pointer-events:auto;white-space:pre-wrap;overflow:hidden}
  .text-box[contenteditable="true"]{outline:2px dashed rgba(255,255,255,0.08)}
  #thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .thumb-wrap{display:flex;flex-direction:column;align-items:center}
  .thumb-wrap canvas{cursor:pointer;border-radius:6px;border:1px solid rgba(255,255,255,0.04)}
  .sidepanel{display:flex;gap:12px;align-items:center;margin-left:auto}
  input[type="file"]{display:none}
  .muted{color:var(--muted);font-size:13px}
  .flex{display:flex;gap:8px;align-items:center}
  .json-input{display:none}
  .page-controls{display:flex;gap:6px;align-items:center}
  @media (max-width:900px){ .container{padding:8px} .toolbar{gap:6px} header h1{font-size:15px} }
</style>
</head>
<body>
<header>
  <div class="left">
    <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="logo"/>
    <div>
      <h1>Smarttool Hub — PDF Editor (Full)</h1>
      <div style="font-size:12px;color:#e6f7ff90">IndexedDB | Rich-text | Image crop | Page reorder | Export</div>
    </div>
  </div>

  <div class="sidepanel">
    <div class="muted">Project:</div>
    <input id="projectName" placeholder="My PDF Project" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:8px;color:#fff">
    <button id="exportJsonBtn" class="btn small"><i class="fa fa-file-export"></i> Export JSON</button>
    <button id="importJsonBtn" class="btn small"><i class="fa fa-file-import"></i> Import JSON</button>
    <input id="importJsonFile" type="file" accept="application/json" class="json-input">
    <button id="zipBtn" class="btn small"><i class="fa fa-file-zipper"></i> Download ZIP</button>
  </div>
</header>

<div class="container">
  <div class="card">

    <div class="toolbar">
      <label class="btn">
        <i class="fa fa-file-arrow-up"></i> Open PDF
        <input id="fileInput" type="file" accept="application/pdf">
      </label>

      <div class="flex">
        <button id="textBtn" class="btn small"><i class="fa fa-font"></i> Text</button>
        <button id="drawBtn" class="btn small"><i class="fa fa-pencil"></i> Draw</button>
        <button id="highlightBtn" class="btn small"><i class="fa fa-highlighter"></i> Highlight</button>
        <label class="btn small">
          <i class="fa fa-image"></i> Image
          <input id="imgInput" type="file" accept="image/*">
        </label>
      </div>

      <select id="fontSelect" style="padding:6px;border-radius:8px;background:#071124;color:#fff">
        <option value="Arial">Arial</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Courier New">Courier New</option>
        <option value="Georgia">Georgia</option>
        <option value="Verdana">Verdana</option>
      </select>

      <select id="sizeSel" title="Font/Brush size">
        <option value="12">12</option><option value="16" selected>16</option><option value="20">20</option><option value="28">28</option><option value="36">36</option>
      </select>

      <input id="colorInp" type="color" value="#ff4757" title="Color">

      <div class="page-controls" style="margin-left:auto">
        <button id="prevBtn" class="btn small"><i class="fa fa-chevron-left"></i></button>
        <div id="pageIndicator" style="padding:6px 10px;background:rgba(255,255,255,0.02);border-radius:8px">0 / 0</div>
        <button id="nextBtn" class="btn small"><i class="fa fa-chevron-right"></i></button>
      </div>

      <div style="margin-left:8px;display:flex;gap:8px">
        <button id="undoBtn" class="btn small"><i class="fa fa-rotate-left"></i> Undo</button>
        <button id="redoBtn" class="btn small"><i class="fa fa-rotate-right"></i> Redo</button>
        <button id="saveBtn" class="btn small"><i class="fa fa-floppy-disk"></i> Save</button>
        <button id="downloadBtn" class="btn primary small"><i class="fa fa-download"></i> Download PDF</button>
      </div>
    </div>

    <div style="display:flex;gap:12px;flex-wrap:wrap">
      <div style="flex:1;min-width:420px">
        <div class="canvas-wrap" id="canvasWrap" style="max-width:980px">
          <canvas id="pdfCanvas"></canvas>
          <canvas id="annotCanvas" style="position:absolute;left:0;top:0;pointer-events:auto"></canvas>
          <div id="annotLayer" style="position:absolute;left:0;top:0;pointer-events:none"></div>
        </div>

        <div id="thumbs" style="margin-top:12px"></div>
      </div>

      <div style="width:310px">
        <div class="card" style="padding:12px;background:#0c1320">
          <h3 style="margin:0 0 8px 0">Selected Item</h3>
          <div id="selectionInfo" class="muted">No selection</div>
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:10px 0">
          <div style="display:flex;flex-direction:column;gap:8px">
            <label class="muted">Font</label>
            <select id="selFont" style="padding:6px;border-radius:8px;background:#071124;color:#fff"></select>
            <label class="muted">Size</label>
            <input id="selSize" type="number" value="16" style="padding:6px;border-radius:8px;background:#071124;color:#fff">
            <label class="muted">Color</label>
            <input id="selColor" type="color" value="#ffffff">
            <div style="display:flex;gap:8px">
              <button id="boldBtn" class="btn small">B</button>
              <button id="italicBtn" class="btn small"><i class="fa fa-italic"></i></button>
              <button id="deleteBtn" class="btn small"><i class="fa fa-trash"></i></button>
            </div>
            <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:10px 0">
            <div style="display:flex;gap:8px">
              <button id="addPageBtn" class="btn small"><i class="fa fa-plus"></i> Add Page</button>
              <button id="delPageBtn" class="btn small"><i class="fa fa-trash-can"></i> Delete Page</button>
            </div>
            <div style="margin-top:10px">
              <button id="reorderModeBtn" class="btn small">Toggle Reorder Pages</button>
            </div>
            <div style="margin-top:10px">
              <button id="exportProjectBtn" class="btn small">Export Project JSON</button>
              <button id="importProjectBtn" class="btn small">Import Project JSON</button>
              <input id="importProjectFile" type="file" accept="application/json" style="display:none">
            </div>
          </div>
        </div>

        <div class="card" style="padding:12px;margin-top:12px;background:#0c1320">
          <h3 style="margin:0 0 8px 0">Image Cropper</h3>
          <div><input id="cropBtn" class="btn small" value="Open Cropper" readonly></div>
          <div id="cropPreview" style="margin-top:8px"></div>
          <div style="margin-top:8px;font-size:13px;color:var(--muted)">Use when inserting images to crop/rotate before placing.</div>
        </div>

      </div>
    </div>

  </div>
</div>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://unpkg.com/idb-keyval@6/dist/idb-keyval.iife.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

<script>
/* Full-featured PDF editor:
   - IndexedDB (idbKeyval) persistence
   - Rich text (fonts, size, bold/italic)
   - Text drag/resize/rotate (interact.js)
   - Image insert + cropper
   - Page reorder (SortableJS)
   - Export/import project JSON & ZIP
   - Flatten to PDF (pdf-lib)
   Notes: This is a comprehensive client-side tool. For huge PDFs, performance may vary.
*/

// Globals & DOM
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
const fileInput = document.getElementById('fileInput'), imgInput = document.getElementById('imgInput');
const pdfCanvas = document.getElementById('pdfCanvas'), annotCanvas = document.getElementById('annotCanvas'), annotLayer = document.getElementById('annotLayer');
const canvasWrap = document.getElementById('canvasWrap'), thumbs = document.getElementById('thumbs');
const pageIndicator = document.getElementById('pageIndicator');
const textBtn = document.getElementById('textBtn'), drawBtn = document.getElementById('drawBtn'), highlightBtn = document.getElementById('highlightBtn');
const sizeSel = document.getElementById('sizeSel'), colorInp = document.getElementById('colorInp'), fontSelect = document.getElementById('fontSelect');
const prevBtn = document.getElementById('prevBtn'), nextBtn = document.getElementById('nextBtn');
const undoBtn = document.getElementById('undoBtn'), redoBtn = document.getElementById('redoBtn');
const saveBtn = document.getElementById('saveBtn'), downloadBtn = document.getElementById('downloadBtn');
const projectNameEl = document.getElementById('projectName');

const selFont = document.getElementById('selFont'), selSize = document.getElementById('selSize'), selColor = document.getElementById('selColor');
const boldBtn = document.getElementById('boldBtn'), italicBtn = document.getElementById('italicBtn'), deleteBtn = document.getElementById('deleteBtn');
const addPageBtn = document.getElementById('addPageBtn'), delPageBtn = document.getElementById('delPageBtn');
const reorderModeBtn = document.getElementById('reorderModeBtn');
const exportJsonBtn = document.getElementById('exportJsonBtn'), importJsonBtn = document.getElementById('importJsonBtn'), importJsonFile = document.getElementById('importJsonFile');
const zipBtn = document.getElementById('zipBtn');
const cropPreview = document.getElementById('cropPreview'), cropBtn = document.getElementById('cropBtn');
const exportProjectBtn = document.getElementById('exportProjectBtn'), importProjectBtn = document.getElementById('importProjectBtn'), importProjectFile = document.getElementById('importProjectFile');

const ctxPdf = pdfCanvas.getContext('2d'), ctxAnnot = annotCanvas.getContext('2d');

// State
let pdfDoc = null, fileBytes = null, pageCount = 0, currentPage = 1, scale = 1.3;
let mode = 'draw'; // draw, highlight, text
let drawColor = colorInp.value, drawSize = parseInt(sizeSel.value,10), fontFamily = fontSelect.value, fontSize = parseInt(sizeSel.value,10);
let annotations = []; // array length = pageCount; each entry: {drawingsDataURL, texts:[], images:[]}
let undoStack = [], redoStack = [];
let selectedEl = null;
const STORAGE_KEY = 'smarttool_full_pdf_project_v1';

// IDB wrapper using idbKeyval
const { set: idbSet, get: idbGet, del: idbDel } = idbKeyval;

// Utility
function genId(prefix='id'){ return prefix + '_' + Math.random().toString(36).slice(2,9); }
function hexToRgba(hex, a=1){ const h=hex.replace('#',''); const n=parseInt(h,16); return `rgba(${(n>>16)&255},${(n>>8)&255},${n&255},${a})`; }

// Resize canvases
function setCanvasSize(w,h){
  pdfCanvas.width = w; pdfCanvas.height = h;
  annotCanvas.width = w; annotCanvas.height = h;
  annotCanvas.style.width = pdfCanvas.width + 'px';
  annotCanvas.style.height = pdfCanvas.height + 'px';
  annotLayer.style.width = pdfCanvas.width + 'px';
  annotLayer.style.height = pdfCanvas.height + 'px';
  canvasWrap.style.height = pdfCanvas.height + 'px';
}

// Undo/Redo
function pushUndo(desc='change'){
  const snap = JSON.stringify({annotations, currentPage});
  undoStack.push(snap);
  if(undoStack.length>80) undoStack.shift();
  redoStack = [];
}
function doUndo(){
  if(!undoStack.length) return;
  const snap = undoStack.pop();
  redoStack.push(JSON.stringify({annotations, currentPage}));
  const parsed = JSON.parse(snap);
  annotations = parsed.annotations; currentPage = parsed.currentPage || 1;
  renderPage(currentPage);
}
function doRedo(){
  if(!redoStack.length) return;
  const snap = redoStack.pop();
  undoStack.push(JSON.stringify({annotations, currentPage}));
  const parsed = JSON.parse(snap);
  annotations = parsed.annotations; currentPage = parsed.currentPage || 1;
  renderPage(currentPage);
}

// Persistence: save project to IndexedDB (store pdf bytes & annotations)
async function saveProject(){
  const project = {
    name: projectNameEl.value || ('Project_' + new Date().toISOString()),
    fileName: (fileInput.files[0]||{}).name || '',
    fileBytes: fileBytes ? arrayBufferToBase64(fileBytes) : null,
    annotations,
    pageOrder: annotations.map((_,i)=>i) // order if needed
  };
  await idbSet(STORAGE_KEY, project);
  alert('Project saved to browser (IndexedDB).');
}
async function loadProjectFromDB(){
  const project = await idbGet(STORAGE_KEY);
  if(!project) return alert('No saved project found in this browser.');
  projectNameEl.value = project.name || '';
  if(project.fileBytes){
    fileBytes = base64ToArrayBuffer(project.fileBytes);
    await loadPDFBytes(fileBytes);
    annotations = project.annotations || annotations;
    renderPage(1);
  } else {
    annotations = project.annotations || annotations;
    renderPage(currentPage);
  }
}

// Helpers for base64 conversion
function arrayBufferToBase64(buf){
  const bytes = new Uint8Array(buf);
  let binary = '';
  const chunk = 0x8000;
  for(let i=0;i<bytes.length;i+=chunk){
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
  }
  return btoa(binary);
}
function base64ToArrayBuffer(base64){
  const binary = atob(base64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for(let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i);
  return bytes.buffer;
}

// Load PDF from file input or bytes
fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  fileBytes = await f.arrayBuffer();
  await loadPDFBytes(fileBytes);
  annotations = createEmptyAnnotations(pageCount);
  pushUndo('load-pdf'); saveTempToIDB();
});

async function loadPDFBytes(bytes){
  pdfDoc = await pdfjsLib.getDocument({data: bytes}).promise;
  pageCount = pdfDoc.numPages;
  currentPage = 1;
  await renderThumbnails();
  await renderPage(1);
  pageIndicator.textContent = `${currentPage} / ${pageCount}`;
}

// Create empty annotations
function createEmptyAnnotations(n){
  const arr = [];
  for(let i=0;i<n;i++) arr.push({drawingsDataURL:null, texts:[], images:[]});
  return arr;
}

// Render thumbnails (Sortable for reorder)
let sortable = null;
async function renderThumbnails(){
  thumbs.innerHTML = '';
  for(let p=1;p<=pageCount;p++){
    const pg = await pdfDoc.getPage(p);
    const vp = pg.getViewport({scale:0.16});
    const c = document.createElement('canvas'); c.width = vp.width; c.height = vp.height;
    await pg.render({canvasContext:c.getContext('2d'), viewport:vp}).promise;
    const wrap = document.createElement('div'); wrap.className='thumb-wrap';
    wrap.dataset.page = p;
    wrap.appendChild(c);
    const lbl = document.createElement('div'); lbl.textContent = p; lbl.style.color='#cfe6ff'; lbl.style.fontSize='13px';
    wrap.appendChild(lbl);
    wrap.style.cursor='grab';
    wrap.addEventListener('click', ()=>{ saveCurrentAnnotations(); currentPage = p; renderPage(p); window.scrollTo({top:document.body.scrollHeight, behavior:'smooth'}); });
    thumbs.appendChild(wrap);
  }
  // enable sortable
  if(sortable) { sortable.destroy(); sortable = null; }
  sortable = Sortable.create(thumbs, {
    animation:150,
    onEnd: (evt) => {
      // reorder annotations array
      const oldIndex = evt.oldIndex, newIndex = evt.newIndex;
      const item = annotations.splice(oldIndex,1)[0];
      annotations.splice(newIndex,0,item);
      // also reorder page renders by swapping nothing else (pages indexes map to annotations)
      pushUndo('reorder-pages'); saveTempToIDB();
      // update UI numbers
      renderThumbnails(); renderPage(currentPage);
    }
  });
}

// Render a single page
async function renderPage(pageNum){
  if(!pdfDoc) return;
  const page = await pdfDoc.getPage(pageNum);
  const vp0 = page.getViewport({scale:1});
  const containerW = Math.min(980, window.innerWidth - 200);
  const targetScale = (containerW / vp0.width) * (scale/1.3);
  const viewport = page.getViewport({scale: targetScale});
  setCanvasSize(viewport.width, viewport.height);
  await page.render({canvasContext: ctxPdf, viewport}).promise;

  // draw saved drawings
  ctxAnnot.clearRect(0,0,annotCanvas.width,annotCanvas.height);
  annotLayer.innerHTML = '';
  const ann = annotations[pageNum-1];
  if(ann && ann.drawingsDataURL){
    const img = new Image();
    img.onload = ()=> ctxAnnot.drawImage(img,0,0,annotCanvas.width,annotCanvas.height);
    img.src = ann.drawingsDataURL;
  }
  // create text and image DOMs
  if(ann){
    (ann.texts||[]).forEach(t => createTextBoxDOM(t));
    (ann.images||[]).forEach(i => createImageDOM(i));
  }
  pageIndicator.textContent = `${pageNum} / ${pageCount}`;
}

// DOM annotation helpers
function createTextBoxDOM(t){
  const div = document.createElement('div'); div.className='text-box';
  div.dataset.id = t.id || genId('t');
  div.style.left = (t.x * annotCanvas.width) + 'px';
  div.style.top = (t.y * annotCanvas.height) + 'px';
  div.style.width = (t.w * annotCanvas.width) + 'px';
  div.style.height = (t.h * annotCanvas.height) + 'px';
  div.style.fontSize = (t.fontSize || 16) + 'px';
  div.style.fontFamily = t.fontFamily || 'Arial';
  div.innerHTML = t.html || 'Text';
  annotLayer.appendChild(div);
  enableInteract(div);
  div.addEventListener('dblclick', ()=> { div.contentEditable = true; div.focus(); });
  div.addEventListener('blur', ()=> {
    div.contentEditable = false;
    saveTextBoxBack(div); pushUndo('edit-text'); saveTempToIDB();
  });
  div.addEventListener('click', (e)=> { e.stopPropagation(); selectElement(div); });
}

function createImageDOM(it){
  const img = new Image(); img.dataset.id = it.id || genId('i'); img.src = it.dataURL;
  img.style.position='absolute'; img.style.left=(it.x*annotCanvas.width)+'px'; img.style.top=(it.y*annotCanvas.height)+'px';
  img.style.width=(it.w*annotCanvas.width)+'px'; img.style.height=(it.h*annotCanvas.height)+'px'; img.style.cursor='move';
  annotLayer.appendChild(img);
  enableInteract(img, true);
  img.addEventListener('click', (e)=>{ e.stopPropagation(); selectElement(img); });
}

// Save DOM text box back to annotations
function saveTextBoxBack(div){
  const pageIdx = currentPage-1;
  annotations[pageIdx] = annotations[pageIdx] || {drawingsDataURL:null, texts:[], images:[]};
  const wrap = annotLayer.getBoundingClientRect(), rect = div.getBoundingClientRect();
  const x = (rect.left - wrap.left) / annotCanvas.width;
  const y = (rect.top - wrap.top) / annotCanvas.height;
  const w = rect.width / annotCanvas.width;
  const h = rect.height / annotCanvas.height;
  const html = div.innerHTML;
  const fontSize = parseInt(window.getComputedStyle(div).fontSize,10) || 16;
  const fontFamily = window.getComputedStyle(div).fontFamily || 'Arial';
  const id = div.dataset.id;
  const existing = (annotations[pageIdx].texts||[]).find(tt=>tt.id===id);
  const obj = {id, x, y, w, h, html, fontSize, fontFamily};
  if(existing) Object.assign(existing, obj); else annotations[pageIdx].texts.push(obj);
}

// Save image back
function saveImageBack(img){
  const pageIdx = currentPage-1;
  annotations[pageIdx] = annotations[pageIdx] || {drawingsDataURL:null, texts:[], images:[]};
  const wrap = annotLayer.getBoundingClientRect(), rect = img.getBoundingClientRect();
  const x = (rect.left - wrap.left) / annotCanvas.width;
  const y = (rect.top - wrap.top) / annotCanvas.height;
  const w = rect.width / annotCanvas.width;
  const h = rect.height / annotCanvas.height;
  const id = img.dataset.id;
  const existing = (annotations[pageIdx].images||[]).find(ii=>ii.id===id);
  const obj = {id, x, y, w, h, dataURL: img.src};
  if(existing) Object.assign(existing, obj); else annotations[pageIdx].images.push(obj);
}

// Interact.js: enable drag/resize/rotate for elements
function enableInteract(el, isImage=false){
  interact(el)
    .draggable({listeners:{move(event){ const target = event.target; const dx = (parseFloat(target.getAttribute('data-x'))||0) + event.dx; const dy = (parseFloat(target.getAttribute('data-y'))||0) + event.dy; target.style.transform = `translate(${dx}px, ${dy}px) rotate(${target.getAttribute('data-rot')||0}deg)`; target.setAttribute('data-x', dx); target.setAttribute('data-y', dy); } ,end(){ /* no-op */ }}})
    .on('doubletap', function(){})
    .gesturable(true);

  interact(el).gesturable({
    listeners: {
      move(event){
        const target = event.target;
        const currentRot = parseFloat(target.getAttribute('data-rot')||0);
        const newRot = currentRot + event.da;
        target.style.transform = `translate(${target.getAttribute('data-x')||0}px, ${target.getAttribute('data-y')||0}px) rotate(${newRot}deg)`;
        target.setAttribute('data-rot', newRot);
      }
    }
  });

  // resize
  interact(el).resizable({
    edges: { left:true, right:true, bottom:true, top:true },
    listeners: {
      move (event) {
        const target = event.target;
        let x = (parseFloat(target.getAttribute('data-x'))||0);
        let y = (parseFloat(target.getAttribute('data-y'))||0);

        // update the element's style
        target.style.width  = event.rect.width + 'px';
        target.style.height = event.rect.height + 'px';

        // translate when resizing from top or left edges
        x += event.deltaRect.left;
        y += event.deltaRect.top;

        target.style.transform = `translate(${x}px, ${y}px) rotate(${target.getAttribute('data-rot')||0}deg)`;
        target.setAttribute('data-x', x);
        target.setAttribute('data-y', y);
      },
      end (ev) { 
        // Save back to annotations
        if(el.tagName.toLowerCase()==='img') saveImageBack(el);
        else saveTextBoxBack(el);
        pushUndo('resize'); saveTempToIDB();
      }
    },
    inertia:true
  });
}

// Drawing handlers on annotCanvas
annotCanvas.addEventListener('pointerdown', (ev)=>{
  if(!pdfDoc) return;
  if(mode === 'text') return; // text handled by clicking canvasWrap
  const rect = annotCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (annotCanvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (annotCanvas.height / rect.height);
  if(mode==='draw' || mode==='highlight'){
    drawing = true; ctxAnnot.globalCompositeOperation='source-over';
    if(mode==='draw'){ ctxAnnot.lineWidth = drawSize; ctxAnnot.lineCap='round'; ctxAnnot.strokeStyle = drawColor; ctxAnnot.beginPath(); ctxAnnot.moveTo(x,y); pushUndo('draw'); }
    else { ctxAnnot.fillStyle = hexToRgba(drawColor, 0.35); ctxAnnot.fillRect(x - drawSize*4, y - drawSize*2, drawSize*20, drawSize*4); saveDrawingLayer(); }
  }
});
annotCanvas.addEventListener('pointermove', (ev)=>{ if(!drawing) return; const rect = annotCanvas.getBoundingClientRect(); const x=(ev.clientX-rect.left)*(annotCanvas.width/rect.width); const y=(ev.clientY-rect.top)*(annotCanvas.height/rect.height); ctxAnnot.lineTo(x,y); ctxAnnot.stroke(); });
annotCanvas.addEventListener('pointerup', ()=>{ if(drawing){ ctxAnnot.closePath(); drawing=false; saveDrawingLayer(); }});

// Save drawing as dataURL
function saveDrawingLayer(){
  annotations[currentPage-1] = annotations[currentPage-1] || {drawingsDataURL:null, texts:[], images:[]};
  annotations[currentPage-1].drawingsDataURL = annotCanvas.toDataURL();
  saveTempToIDB();
}

// Click on canvasWrap to add text box
canvasWrap.addEventListener('click', (ev)=>{
  if(!pdfDoc) return;
  if(mode !== 'text') return;
  const rect = annotCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (annotCanvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (annotCanvas.height / rect.height);
  const wRel = 0.28, hRel = 0.08;
  const t = { id: genId('t'), x: x/annotCanvas.width, y: y/annotCanvas.height, w: wRel, h: hRel, html: 'New text', fontSize: parseInt(sizeSel.value,10), fontFamily: fontSelect.value};
  annotations[currentPage-1] = annotations[currentPage-1] || {drawingsDataURL:null, texts:[], images:[]};
  annotations[currentPage-1].texts.push(t);
  createTextBoxDOM(t);
  pushUndo('add-text'); saveTempToIDB();
});

// Image insert + crop
let cropper = null;
imgInput.addEventListener('change',(e)=>{
  const f = e.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = function(){
    openCropper(reader.result);
  };
  reader.readAsDataURL(f);
  e.target.value = '';
});

function openCropper(dataUrl){
  cropPreview.innerHTML = '';
  const img = document.createElement('img'); img.src = dataUrl; img.style.maxWidth='100%'; cropPreview.appendChild(img);
  cropper = new Cropper(img, { viewMode:1, autoCropArea:0.8, responsive:true });
  cropBtn.value = 'Crop & Place';
  cropBtn.onclick = ()=> {
    const canvas = cropper.getCroppedCanvas();
    const durl = canvas.toDataURL('image/png');
    // place on current page center
    const obj = { id: genId('i'), x:0.1, y:0.1, w:0.5, h:0.4, dataURL:durl };
    annotations[currentPage-1] = annotations[currentPage-1] || {drawingsDataURL:null, texts:[], images:[]};
    annotations[currentPage-1].images.push(obj);
    createImageDOM(obj);
    saveImageBack(document.querySelector(`[data-id="${obj.id}"]`));
    pushUndo('add-image'); saveTempToIDB();
    cropper.destroy(); cropper = null; cropPreview.innerHTML=''; cropBtn.value='Open Cropper'; cropBtn.onclick = ()=> {};
  };
}

// selection UI
function selectElement(el){
  selectedEl = el;
  document.getElementById('selectionInfo').textContent = 'Selected: ' + (el.tagName.toLowerCase()==='img' ? 'Image' : 'Text');
  if(el.tagName.toLowerCase()==='img'){
    selFont.disabled = true; selSize.disabled = true; selColor.disabled = true;
  } else {
    selFont.disabled = false; selSize.disabled = false; selColor.disabled = false;
    selFont.value = window.getComputedStyle(el).fontFamily.replace(/"/g,'') || 'Arial';
    selSize.value = parseInt(window.getComputedStyle(el).fontSize,10) || 16;
    selColor.value = rgbToHex(window.getComputedStyle(el).color || '#ffffff');
  }
}

// helpers color convert
function rgbToHex(rgb){
  const m = rgb.match(/\d+/g);
  if(!m) return '#ffffff';
  return '#' + ((1<<24) + (parseInt(m[0])<<16) + (parseInt(m[1])<<8) + parseInt(m[2])).toString(16).slice(1);
}

// toolbar actions on selection
selFont.addEventListener('change', ()=> { if(!selectedEl) return; selectedEl.style.fontFamily = selFont.value; saveTextBoxBack(selectedEl); saveTempToIDB(); });
selSize.addEventListener('change', ()=> { if(!selectedEl) return; selectedEl.style.fontSize = (selSize.value)+'px'; saveTextBoxBack(selectedEl); saveTempToIDB(); });
selColor.addEventListener('change', ()=> { if(!selectedEl) return; selectedEl.style.color = selColor.value; saveTextBoxBack(selectedEl); saveTempToIDB(); });
boldBtn.addEventListener('click', ()=> { if(!selectedEl) return; const cur = window.getComputedStyle(selectedEl).fontWeight; selectedEl.style.fontWeight = (cur === '700' || cur === 'bold') ? '400' : '700'; saveTextBoxBack(selectedEl); saveTempToIDB(); });
italicBtn.addEventListener('click', ()=> { if(!selectedEl) return; const cur = window.getComputedStyle(selectedEl).fontStyle; selectedEl.style.fontStyle = (cur === 'italic') ? 'normal' : 'italic'; saveTextBoxBack(selectedEl); saveTempToIDB(); });
deleteBtn.addEventListener('click', ()=> { if(!selectedEl) return; const id = selectedEl.dataset.id; const pageAnn = annotations[currentPage-1]; if(selectedEl.tagName.toLowerCase()==='img') pageAnn.images = pageAnn.images.filter(x=>x.id!==id); else pageAnn.texts = pageAnn.texts.filter(x=>x.id!==id); selectedEl.remove(); selectedEl = null; saveTempToIDB(); pushUndo('delete'); });

// page add/delete
addPageBtn.addEventListener('click', ()=>{
  // add a blank page by cloning last page size — simpler approach: append empty annotation and increment pageCount
  annotations.push({drawingsDataURL:null, texts:[], images:[]});
  pageCount++;
  pushUndo('add-page'); saveTempToIDB();
  renderThumbnails();
});
delPageBtn.addEventListener('click', ()=>{
  if(!confirm('Delete current page?')) return;
  annotations.splice(currentPage-1,1);
  pageCount--;
  if(currentPage>pageCount) currentPage = pageCount;
  pushUndo('delete-page'); saveTempToIDB();
  renderThumbnails(); renderPage(currentPage);
});

// reorder mode toggling simply toggles a class (sortable is always enabled)
reorderModeBtn.addEventListener('click', ()=> {
  thumbs.classList.toggle('reorder-on');
  alert('Drag thumbnails to reorder pages.');
});

// prev/next
prevBtn.addEventListener('click', ()=>{ if(currentPage>1){ saveCurrentAnnotations(); currentPage--; renderPage(currentPage); }});
nextBtn.addEventListener('click', ()=>{ if(currentPage<pageCount){ saveCurrentAnnotations(); currentPage++; renderPage(currentPage); }});

// save current page annotations (drawings + dom items)
function saveCurrentAnnotations(){
  saveDrawingLayer();
  // save DOM texts/images to annotations arrays
  // texts/images are saved on blur/resize, but ensure any active content edited is stored
  document.querySelectorAll('.text-box').forEach(tb => { if(tb.isContentEditable) tb.blur(); saveTextBoxBack(tb); });
  document.querySelectorAll('#annotLayer img').forEach(img=>saveImageBack(img));
}

// temp save to IndexedDB (small autosave)
async function saveTempToIDB(){
  const project = { name: projectNameEl.value || '', fileName: (fileInput.files[0]||{}).name || '', fileBytes: fileBytes? arrayBufferToBase64(fileBytes) : null, annotations};
  await idbSet(STORAGE_KEY, project);
}

// load/save full project JSON (import/export)
exportProjectBtn.addEventListener('click', async ()=>{
  const project = { name: projectNameEl.value || '', fileName: (fileInput.files[0]||{}).name || '', fileBytes: fileBytes? arrayBufferToBase64(fileBytes):null, annotations };
  const blob = new Blob([JSON.stringify(project)], {type:'application/json'});
  saveAs(blob, (project.name || 'project') + '.json');
});
importProjectBtn.addEventListener('click', ()=> importProjectFile.click());
importProjectFile.addEventListener('change', async (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const txt = await f.text(); const parsed = JSON.parse(txt);
  projectNameEl.value = parsed.name || ''; if(parsed.fileBytes){ fileBytes = base64ToArrayBuffer(parsed.fileBytes); await loadPDFBytes(fileBytes); } annotations = parsed.annotations || annotations; renderThumbnails(); renderPage(currentPage); saveTempToIDB();
});

// Export JSON quick
exportJsonBtn.addEventListener('click', ()=> {
  const obj = { name: projectNameEl.value || '', annotations, pageCount, timestamp: Date.now() };
  const blob = new Blob([JSON.stringify(obj)], {type:'application/json'});
  saveAs(blob, (projectNameEl.value||'export') + '.json');
});
importJsonBtn.addEventListener('click', ()=> importJsonFile.click());
importJsonFile.addEventListener('change', async (e)=> {
  const f = e.target.files[0]; if(!f) return;
  const txt = await f.text(); const parsed = JSON.parse(txt);
  annotations = parsed.annotations || annotations; renderThumbnails(); renderPage(currentPage); saveTempToIDB();
});

// ZIP download (include edited PDF and project JSON)
zipBtn.addEventListener('click', async ()=>{
  if(!pdfDoc) return alert('Load a PDF first');
  saveCurrentAnnotations();
  zipBtn.disabled = true; zipBtn.textContent = 'Preparing...';
  try{
    const zip = new JSZip();
    // Add project JSON
    const proj = { name: projectNameEl.value||'', annotations, pageCount, timestamp: Date.now() };
    zip.file('project.json', JSON.stringify(proj));
    // Add edited PDF as binary
    const editedPdfBytes = await exportEditedPdfBytes();
    zip.file('edited.pdf', editedPdfBytes);
    const content = await zip.generateAsync({type:'blob'});
    saveAs(content, (projectNameEl.value||'project') + '.zip');
  }catch(e){ console.error(e); alert('ZIP failed: '+e); }
  finally{ zipBtn.disabled=false; zipBtn.textContent='Download ZIP'; }
});

// Download flattened PDF
downloadBtn.addEventListener('click', async ()=> {
  if(!pdfDoc) return alert('Load a PDF first');
  saveCurrentAnnotations();
  downloadBtn.disabled = true; downloadBtn.textContent = 'Preparing...';
  try{
    const outBytes = await exportEditedPdfBytes();
    const blob = new Blob([outBytes], {type:'application/pdf'});
    saveAs(blob, (projectNameEl.value||'edited') + '.pdf');
  }catch(e){ console.error(e); alert('Download failed: '+e); }
  finally{ downloadBtn.disabled=false; downloadBtn.textContent='Download PDF'; }
});

// Export edited PDF bytes using PDFLib
async function exportEditedPdfBytes(){
  const srcPdf = await PDFLib.PDFDocument.load(fileBytes);
  const outPdf = await PDFLib.PDFDocument.create();
  const copied = await outPdf.copyPages(srcPdf, srcPdf.getPageIndices());
  for(let i=0;i<copied.length;i++){
    const page = copied[i];
    outPdf.addPage(page);
    const ann = annotations[i];
    if(!ann) continue;
    const { width, height } = page.getSize();
    // compose overlay
    const tmp = document.createElement('canvas'); tmp.width = width; tmp.height = height;
    const tctx = tmp.getContext('2d');
    // drawings
    if(ann.drawingsDataURL){
      const dimg = new Image();
      await new Promise((res,rej)=>{ dimg.onload=res; dimg.onerror=rej; dimg.src = ann.drawingsDataURL; });
      tctx.drawImage(dimg,0,0,width,height);
    }
    // images
    for(const im of (ann.images||[])){
      const imEl = new Image();
      await new Promise((res,rej)=>{ imEl.onload=res; imEl.onerror=rej; imEl.src = im.dataURL; });
      tctx.drawImage(imEl, im.x * width, im.y * height, im.w * width, im.h * height);
    }
    // texts
    for(const tx of (ann.texts||[])){
      const fontSz = tx.fontSize || 16;
      tctx.font = `${fontSz}px ${tx.fontFamily || 'Arial'}`;
      const textContent = (tx.html || '').replace(/<[^>]+>/g, '') || ' ';
      tctx.fillStyle = '#ffffff';
      tctx.fillText(textContent, tx.x * width + 4, tx.y * height + fontSz + 4);
    }
    // embed PNG overlay
    const pngDataUrl = tmp.toDataURL('image/png');
    const pngBytes = await (await fetch(pngDataUrl)).arrayBuffer();
    const img = await outPdf.embedPng(pngBytes);
    page.drawImage(img, {x:0,y:0,width,height});
  }
  const outBytes = await outPdf.save();
  return outBytes;
}

// autosave on interval
setInterval(()=>{ saveTempToIDB(); }, 4000);

// Save/load from IndexedDB UI buttons
document.getElementById('saveBtn').addEventListener('click', saveProject);
document.getElementById('loadLocal').addEventListener('click', loadProjectFromDB); // note: loadLocal element id previously exists in earlier layouts but not in this exact UI; if present, binds

// Export/Import JSON quick buttons already bound above (exportProjectBtn etc)
exportJsonBtn.addEventListener('click', ()=> { const obj={ name: projectNameEl.value||'', annotations }; const blob = new Blob([JSON.stringify(obj)], {type:'application/json'}); saveAs(blob, (projectNameEl.value||'export') + '.json'); });
importJsonBtn.addEventListener('click', ()=> importJsonFile.click());

// selection & UI default
function selectNone(){ selectedEl=null; document.getElementById('selectionInfo').textContent='No selection'; }
document.addEventListener('click', (e)=>{ if(!e.target.closest('.text-box') && !e.target.closest('#annotLayer img')) { selectNone(); } });

// helper: save project to IDB when page unload
window.addEventListener('beforeunload', ()=> saveTempToIDB());

// init default
(function init(){
  mode = 'draw'; drawBtn.click();
  // try load last saved project automatically
  (async ()=>{ const project = await idbGet(STORAGE_KEY); if(project){ if(project.fileBytes){ fileBytes = base64ToArrayBuffer(project.fileBytes); await loadPDFBytes(fileBytes); annotations = project.annotations || createEmptyAnnotations(pageCount); renderPage(1); } else { annotations = project.annotations || createEmptyAnnotations(pageCount); renderPage(1);} projectNameEl.value = project.name || ''; } })();
})();

</script>
</body>
</html>
