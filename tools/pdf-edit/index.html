<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF Editor — Smarttool Hub (Fixed)</title>
<meta name="description" content="Edit PDF in your browser: add text, draw, highlight, insert images, and download. Works on GitHub Pages."/>
<link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png"/>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
<style>
  :root{--bg:#071124;--card:#0f1724;--muted:#9aa8bf}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef8}
  header{position:sticky;top:0;z-index:999;display:flex;align-items:center;justify-content:space-between;padding:10px 16px;background:linear-gradient(90deg,#2563eb,#06b6d4)}
  header .left{display:flex;gap:12px;align-items:center}
  header img{width:36px;height:36px;border-radius:8px}
  header h1{margin:0;font-size:17px}
  .container{max-width:980px;margin:18px auto;padding:12px}
  .card{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.5)}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.08);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
  .btn.primary{background:#fff;color:#071124;font-weight:700}
  .small{padding:6px 8px;font-size:13px}
  .canvas-wrap{position:relative;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.06);margin-top:12px;background:#fff}
  canvas{display:block;width:100%}
  #annotLayer{position:absolute;left:0;top:0;pointer-events:none}
  .text-box{position:absolute;padding:6px 8px;background:rgba(0,0,0,0.5);color:#fff;border-radius:6px;border:1px dashed rgba(255,255,255,0.12);cursor:move;pointer-events:auto;min-width:48px;white-space:pre-wrap;overflow:hidden}
  .text-box[contenteditable="true"]{outline:2px dashed rgba(255,255,255,0.25)}
  .text-box.selected{box-shadow:0 0 0 2px #60a5fa}
  .img-handle{position:absolute;width:12px;height:12px;background:#fff;border-radius:2px;right:-6px;bottom:-6px;border:1px solid rgba(0,0,0,0.2);cursor:se-resize;pointer-events:auto}
  .thumbs{margin-top:10px;display:flex;gap:6px;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:13px}
  input[type="file"]{display:none}
  .right{margin-left:auto;display:flex;gap:8px}
  @media (max-width:720px){ .container{padding:8px} header h1{font-size:15px} }
</style>
</head>
<body>
<header>
  <div class="left">
    <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="logo"/>
    <div>
      <h1>Smarttool Hub — PDF Editor</h1>
      <div style="font-size:12px;color:#e6f7ff90">GitHub Pages friendly</div>
    </div>
  </div>
  <div class="right">
    <a class="btn" href="../../index.html">← Back to Home</a>
  </div>
</header>

<div class="container">
  <div class="card">
    <div class="toolbar">
      <label class="btn">
        <i class="fa fa-file-arrow-up"></i> Open PDF
        <input id="fileInput" type="file" accept="application/pdf">
      </label>

      <div style="display:flex;gap:6px;align-items:center">
        <button id="textBtn" class="btn small" title="Add text"><i class="fa fa-font"></i> Text</button>
        <button id="drawBtn" class="btn small" title="Freehand draw"><i class="fa fa-pencil"></i> Draw</button>
        <button id="highlightBtn" class="btn small" title="Highlighter"><i class="fa fa-highlighter"></i> Highlight</button>
        <label class="btn small" title="Insert image">
          <i class="fa fa-image"></i> Image
          <input id="imgInput" type="file" accept="image/*">
        </label>
      </div>

      <select id="fontSelect" style="padding:6px;border-radius:6px;background:#071124;color:#fff" title="Font for new/selected text">
        <option>Arial</option><option>Times New Roman</option><option>Courier New</option><option>Georgia</option><option>Verdana</option>
      </select>

      <select id="sizeSel" title="Font size / Brush size">
        <option value="12">12</option><option value="16" selected>16</option><option value="20">20</option><option value="28">28</option><option value="36">36</option>
      </select>

      <input id="colorInp" type="color" value="#ff4757" title="Text/Brush color" style="margin-left:6px">

      <div class="right" style="margin-left:auto">
        <button id="prevBtn" class="btn small"><i class="fa fa-chevron-left"></i></button>
        <div id="pageIndicator" style="padding:6px 10px;background:rgba(255,255,255,0.06);border-radius:6px">0 / 0</div>
        <button id="nextBtn" class="btn small"><i class="fa fa-chevron-right"></i></button>
        <button id="downloadBtn" class="btn primary small" style="margin-left:8px"><i class="fa fa-download"></i> Download</button>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="pdfCanvas"></canvas>
      <canvas id="annotCanvas" style="position:absolute;left:0;top:0;pointer-events:auto"></canvas>
      <div id="annotLayer" style="position:absolute;left:0;top:0;pointer-events:none"></div>
    </div>

    <div class="thumbs muted" id="thumbsArea">Pages: none</div>
    <div style="margin-top:8px" class="muted">Tip: Text ઉમેરવા "Text" પસંદ કરો અને પેજ પર click કરો. Text box પર double-click → edit. Click → select, toolbar થી font/size/color બદલાય.</div>
  </div>
</div>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

<script>
/* --- Fixed, GitHub Pages-friendly PDF editor --- */

pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

const fileInput = document.getElementById('fileInput');
const imgInput = document.getElementById('imgInput');
const pdfCanvas = document.getElementById('pdfCanvas');
const annotCanvas = document.getElementById('annotCanvas');
const annotLayer = document.getElementById('annotLayer');
const canvasWrap = document.getElementById('canvasWrap');
const thumbsArea = document.getElementById('thumbsArea');

const textBtn = document.getElementById('textBtn');
const drawBtn = document.getElementById('drawBtn');
const highlightBtn = document.getElementById('highlightBtn');
const fontSelect = document.getElementById('fontSelect');
const sizeSel = document.getElementById('sizeSel');
const colorInp = document.getElementById('colorInp');

const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const pageIndicator = document.getElementById('pageIndicator');
const downloadBtn = document.getElementById('downloadBtn');

const ctxPdf = pdfCanvas.getContext('2d');
const ctxAnnot = annotCanvas.getContext('2d');

let pdfDoc = null, fileBytesU8 = null, pageCount = 0, currentPage = 1, scale = 1.3;
let mode = 'draw'; // draw, highlight, text
let drawColor = colorInp.value, drawSize = parseInt(sizeSel.value,10);
let annotations = {}; // pageNum -> { drawingsDataURL, texts:[], images:[] }
let selectedTextBox = null; // <- for toolbar edits
const STORAGE_PREFIX = 'simple_pdf_editor_v1_';

// helpers
function setCanvasSize(w,h){
  pdfCanvas.width=w; pdfCanvas.height=h;
  annotCanvas.width=w; annotCanvas.height=h;
  annotCanvas.style.width = pdfCanvas.width + 'px';
  annotCanvas.style.height = pdfCanvas.height + 'px';
  annotLayer.style.width = pdfCanvas.width + 'px';
  annotLayer.style.height = pdfCanvas.height + 'px';
  canvasWrap.style.height = pdfCanvas.height + 'px';
}
function genId(p='id'){ return p + '_' + Math.random().toString(36).slice(2,9); }
function hexToRgba(hex,a=1){ const h=hex.replace('#',''); const n=parseInt(h,16); return `rgba(${(n>>16)&255},${(n>>8)&255},${n&255},${a})`; }
function saveToLocal(key,obj){ try{ localStorage.setItem(STORAGE_PREFIX+key, JSON.stringify(obj)); }catch(e){} }
function loadFromLocal(key){ try{ const r=localStorage.getItem(STORAGE_PREFIX+key); return r?JSON.parse(r):null; }catch(e){ return null; } }

// PDF load (store as Uint8Array to avoid detach)
fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const nameKey = f.name || 'file';
  try{
    const ab = await f.arrayBuffer();
    fileBytesU8 = new Uint8Array(ab); // keep as U8 for safe reuse
    pdfDoc = await pdfjsLib.getDocument({data: fileBytesU8}).promise;
    pageCount = pdfDoc.numPages; currentPage = 1;

    annotations = loadFromLocal(nameKey) || {};
    await renderThumbnails();
    await renderPage(currentPage);
    saveToLocal('last_filename', nameKey);
  }catch(err){
    console.error(err);
    alert('Failed to load PDF: ' + (err.message || err));
  }
});

// thumbs
async function renderThumbnails(){
  thumbsArea.textContent = '';
  for(let p=1;p<=pageCount;p++){
    const pg = await pdfDoc.getPage(p);
    const vp = pg.getViewport({scale:0.12});
    const c = document.createElement('canvas'); c.width = vp.width; c.height = vp.height;
    await pg.render({canvasContext: c.getContext('2d'), viewport: vp}).promise;
    c.style.marginRight = '6px'; c.style.border='1px solid rgba(255,255,255,0.05)'; c.style.borderRadius='4px'; c.style.cursor='pointer';
    c.onclick = ()=>{ saveCurrentAnnotations(); currentPage = p; renderPage(p); };
    thumbsArea.appendChild(c);
  }
}

// render page
async function renderPage(p){
  if(!pdfDoc) return;
  // clear selection state
  selectedTextBox = null;
  annotLayer.querySelectorAll('.text-box').forEach(el=>el.classList.remove('selected'));

  const page = await pdfDoc.getPage(p);
  const vp0 = page.getViewport({scale:1});
  const containerW = Math.min(920, window.innerWidth - 80);
  const targetScale = (containerW / vp0.width) * (scale/1.3);
  const viewport = page.getViewport({scale: targetScale});
  setCanvasSize(viewport.width, viewport.height);
  await page.render({canvasContext: ctxPdf, viewport}).promise;

  // load annotations
  ctxAnnot.clearRect(0,0,annotCanvas.width,annotCanvas.height);
  annotLayer.innerHTML = '';
  const ann = annotations[p];
  if(ann && ann.drawingsDataURL){
    const img = new Image();
    img.onload = ()=> ctxAnnot.drawImage(img,0,0,annotCanvas.width,annotCanvas.height);
    img.src = ann.drawingsDataURL;
  }
  if(ann){
    (ann.texts||[]).forEach(t => createTextDiv(t));
    (ann.images||[]).forEach(i => createImageEl(i));
  }
  pageIndicator.textContent = `${p} / ${pageCount}`;
}

// drawing & highlight (highlight size comes from drawSize)
let isDrawing = false;
annotCanvas.addEventListener('pointerdown', (ev)=>{
  if(!pdfDoc || mode==='text') return;
  const rect = annotCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (annotCanvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (annotCanvas.height / rect.height);
  if(mode === 'draw'){
    ctxAnnot.beginPath(); ctxAnnot.lineWidth = drawSize; ctxAnnot.lineCap = 'round'; ctxAnnot.strokeStyle = drawColor;
    ctxAnnot.moveTo(x,y); isDrawing = true;
  } else if(mode === 'highlight'){
    ctxAnnot.fillStyle = hexToRgba(drawColor, 0.35);
    // width/height proportional to drawSize
    ctxAnnot.fillRect(x - drawSize*2, y - drawSize, drawSize*10, drawSize*2);
    saveDrawingToPage(currentPage);
  }
});
annotCanvas.addEventListener('pointermove', (ev)=>{
  if(!isDrawing) return;
  const rect = annotCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (annotCanvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (annotCanvas.height / rect.height);
  ctxAnnot.lineTo(x,y); ctxAnnot.stroke();
});
annotCanvas.addEventListener('pointerup', ()=>{ if(isDrawing){ ctxAnnot.closePath(); isDrawing=false; saveDrawingToPage(currentPage); }});

// save drawing layer
function saveDrawingToPage(page){
  annotations[page] = annotations[page] || {drawingsDataURL:null, texts:[], images:[]};
  annotations[page].drawingsDataURL = annotCanvas.toDataURL();
  const key = loadFromLocal('last_filename') || 'autosave';
  saveToLocal(key, annotations);
}

// text add
canvasWrap.addEventListener('click', (ev)=>{
  if(!pdfDoc || mode!=='text') return;
  const rect = annotCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (annotCanvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (annotCanvas.height / rect.height);
  const wRel = 0.28, hRel = 0.08;
  const txt = {
    id: genId('t'),
    x: x/annotCanvas.width, y: y/annotCanvas.height, w: wRel, h: hRel,
    html: 'Type...',
    fontSize: parseInt(sizeSel.value,10),
    color: colorInp.value,
    fontFamily: fontSelect.value
  };
  annotations[currentPage] = annotations[currentPage] || {drawingsDataURL:null, texts:[], images:[]};
  (annotations[currentPage].texts ||= []).push(txt);
  createTextDiv(txt);
  saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
});

// create text DOM (with selection + toolbar binding)
function createTextDiv(t){
  const div = document.createElement('div');
  div.className = 'text-box';
  div.dataset.id = t.id;
  div.style.left = (t.x * annotCanvas.width) + 'px';
  div.style.top  = (t.y * annotCanvas.height) + 'px';
  div.style.width = (t.w * annotCanvas.width) + 'px';
  div.style.height = (t.h * annotCanvas.height) + 'px';
  div.style.fontSize = (t.fontSize || 16) + 'px';
  div.style.fontFamily = t.fontFamily || 'Arial';
  div.style.color = t.color || '#fff';
  div.innerHTML = t.html || '';
  annotLayer.appendChild(div);

  // select
  div.addEventListener('click', (e)=>{
    e.stopPropagation();
    annotLayer.querySelectorAll('.text-box').forEach(el=>el.classList.remove('selected'));
    div.classList.add('selected');
    selectedTextBox = div;
    // sync toolbar to selected text
    fontSelect.value = (t.fontFamily || 'Arial');
    sizeSel.value = (t.fontSize || 16);
    colorInp.value = toHex(div.style.color || '#ffffff');
  });

  // drag
  makeDraggable(div, ()=> saveTextDivToAnnotations(div));

  // edit on dblclick
  div.addEventListener('dblclick', (e)=>{
    e.stopPropagation();
    div.contentEditable = 'true';
    div.focus();
    const onBlur = ()=>{
      div.contentEditable = 'false';
      saveTextDivToAnnotations(div);
      div.removeEventListener('blur', onBlur);
      saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
    };
    div.addEventListener('blur', onBlur);
  });
}

function saveTextDivToAnnotations(div){
  const page = currentPage;
  const wrap = annotLayer.getBoundingClientRect(), rect = div.getBoundingClientRect();
  const x = (rect.left - wrap.left) / annotCanvas.width;
  const y = (rect.top  - wrap.top ) / annotCanvas.height;
  const w = rect.width  / annotCanvas.width;
  const h = rect.height / annotCanvas.height;
  const fontSize = parseInt(getComputedStyle(div).fontSize,10) || 16;
  const fontFamily = getComputedStyle(div).fontFamily || 'Arial';
  const color = rgbToHex(getComputedStyle(div).color || '#ffffff');
  const html = div.innerHTML;
  const id = div.dataset.id;
  annotations[page] = annotations[page] || {drawingsDataURL:null, texts:[], images:[]};
  const arr = annotations[page].texts || [];
  const existing = arr.find(xe => xe.id === id);
  const obj = { id, x, y, w, h, html, fontSize, color, fontFamily };
  if(existing) Object.assign(existing, obj); else arr.push(obj);
  annotations[page].texts = arr;
}

function toHex(any){ // best-effort when element has hex already
  if(/^#/.test(any)) return any;
  return rgbToHex(any);
}
function rgbToHex(rgb){
  const m = (rgb||'').match(/\d+/g);
  if(!m) return '#ffffff';
  const r = (+m[0]).toString(16).padStart(2,'0');
  const g = (+m[1]).toString(16).padStart(2,'0');
  const b = (+m[2]).toString(16).padStart(2,'0');
  return '#' + r + g + b;
}

// toolbar → update selected text live
fontSelect.addEventListener('change', ()=>{
  if(selectedTextBox){
    selectedTextBox.style.fontFamily = fontSelect.value;
    saveTextDivToAnnotations(selectedTextBox);
    saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
  }
});
sizeSel.addEventListener('change', ()=>{
  drawSize = parseInt(sizeSel.value,10); // affects draw/highlighter
  if(selectedTextBox){
    selectedTextBox.style.fontSize = sizeSel.value + 'px';
    saveTextDivToAnnotations(selectedTextBox);
    saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
  }
});
colorInp.addEventListener('change', ()=>{
  drawColor = colorInp.value; // draw/highlighter color
  if(selectedTextBox){
    selectedTextBox.style.color = colorInp.value;
    saveTextDivToAnnotations(selectedTextBox);
    saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
  }
});

// simple draggable
function makeDraggable(el, onEnd){
  el.style.touchAction = 'none';
  el.onpointerdown = function(e){
    e.preventDefault();
    const startX = e.clientX, startY = e.clientY;
    const rect = el.getBoundingClientRect(), wrapRect = annotLayer.getBoundingClientRect();
    const origLeft = rect.left - wrapRect.left, origTop = rect.top - wrapRect.top;
    function move(ev){
      const dx = ev.clientX - startX, dy = ev.clientY - startY;
      el.style.left = (origLeft + dx) + 'px';
      el.style.top  = (origTop  + dy) + 'px';
    }
    function up(){
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
      if(onEnd) onEnd();
      saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
    }
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  };
}

// Image insert + resize handle
imgInput.addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    const data = reader.result;
    const imgObj = { id: genId('i'), x:0.12, y:0.12, w:0.5, h:0.4, dataURL: data };
    annotations[currentPage] = annotations[currentPage] || {drawingsDataURL:null, texts:[], images:[]};
    (annotations[currentPage].images ||= []).push(imgObj);
    createImageEl(imgObj);
    saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
  };
  reader.readAsDataURL(f);
  e.target.value = '';
});

function createImageEl(it){
  const img = new Image();
  img.src = it.dataURL;
  img.dataset.id = it.id;
  img.style.position = 'absolute';
  img.style.left = (it.x * annotCanvas.width) + 'px';
  img.style.top  = (it.y * annotCanvas.height) + 'px';
  img.style.width = (it.w * annotCanvas.width) + 'px';
  img.style.height= (it.h * annotCanvas.height) + 'px';
  img.style.pointerEvents='auto'; img.style.cursor='move';

  const wrap = document.createElement('div');
  wrap.style.position='absolute';
  wrap.style.left=img.style.left; wrap.style.top=img.style.top;
  wrap.style.width=img.style.width; wrap.style.height=img.style.height;
  wrap.appendChild(img);

  const handle = document.createElement('div'); handle.className='img-handle'; wrap.appendChild(handle);
  annotLayer.appendChild(wrap);

  makeDraggable(wrap, ()=> saveImageBack(wrap));
  handle.onpointerdown = function(e){
    e.stopPropagation(); e.preventDefault();
    const startX = e.clientX, startY = e.clientY;
    const startW = wrap.getBoundingClientRect().width, startH = wrap.getBoundingClientRect().height;
    function move(ev){
      const dx = ev.clientX - startX, dy = ev.clientY - startY;
      const nw = Math.max(20, startW + dx), nh = Math.max(20, startH + dy);
      wrap.style.width = nw+'px'; wrap.style.height = nh+'px';
      img.style.width = nw+'px'; img.style.height = nh+'px';
    }
    function up(){
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
      saveImageBack(wrap);
      saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
    }
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  };
  saveImageBack(wrap);
}
function saveImageBack(wrap){
  const wrapRect = annotLayer.getBoundingClientRect();
  const img = wrap.querySelector('img');
  const rect = img.getBoundingClientRect();
  const x = (rect.left - wrapRect.left) / annotCanvas.width;
  const y = (rect.top  - wrapRect.top ) / annotCanvas.height;
  const w = rect.width  / annotCanvas.width;
  const h = rect.height / annotCanvas.height;
  const id = img.dataset.id;
  annotations[currentPage] = annotations[currentPage] || {drawingsDataURL:null, texts:[], images:[]};
  const arr = annotations[currentPage].images || [];
  const existing = arr.find(ii=>ii.id===id);
  const obj = { id, x, y, w, h, dataURL: img.src };
  if(existing) Object.assign(existing, obj); else arr.push(obj);
  annotations[currentPage].images = arr;
}

// nav
prevBtn.addEventListener('click', ()=>{ if(currentPage>1){ saveCurrentAnnotations(); currentPage--; renderPage(currentPage); }});
nextBtn.addEventListener('click', ()=>{ if(currentPage<pageCount){ saveCurrentAnnotations(); currentPage++; renderPage(currentPage); }});
function saveCurrentAnnotations(){
  saveDrawingToPage(currentPage);
  annotLayer.querySelectorAll('.text-box').forEach(tb=> saveTextDivToAnnotations(tb));
  annotLayer.querySelectorAll('div').forEach(w=>{ if(w.querySelector && w.querySelector('img')) saveImageBack(w); });
  saveToLocal(loadFromLocal('last_filename') || 'autosave', annotations);
}

// ---- Export FIX: always clone bytes to avoid detached ArrayBuffer ----
downloadBtn.addEventListener('click', async ()=>{
  if(!pdfDoc || !fileBytesU8) return alert('Load a PDF first');
  saveCurrentAnnotations();
  downloadBtn.disabled = true; downloadBtn.textContent = 'Preparing...';
  try{
    const out = await exportFlattenedPdf();
    const blob = new Blob([out], {type:'application/pdf'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'edited.pdf';
    document.body.appendChild(a); a.click(); a.remove();
  }catch(e){
    console.error(e); alert('Export failed: ' + e);
  }finally{
    downloadBtn.disabled = false; downloadBtn.textContent = 'Download';
  }
});

async function exportFlattenedPdf(){
  // ✅ clone bytes so original buffer never gets detached
  const fresh = new Uint8Array(fileBytesU8); 
  const srcPdf = await PDFLib.PDFDocument.load(fresh);
  const outPdf = await PDFLib.PDFDocument.create();
  const copied = await outPdf.copyPages(srcPdf, srcPdf.getPageIndices());
  for(let i=0;i<copied.length;i++){
    const page = copied[i]; outPdf.addPage(page);
    const ann = annotations[i+1]; if(!ann) continue;
    const { width, height } = page.getSize();

    const tmp = document.createElement('canvas'); tmp.width=width; tmp.height=height;
    const tctx = tmp.getContext('2d');

    if(ann.drawingsDataURL){
      const d = new Image();
      await new Promise((res,rej)=>{ d.onload=res; d.onerror=rej; d.src=ann.drawingsDataURL; });
      tctx.drawImage(d,0,0,width,height);
    }
    for(const im of (ann.images||[])){
      const ii = new Image();
      await new Promise((res,rej)=>{ ii.onload=res; ii.onerror=rej; ii.src=im.dataURL; });
      tctx.drawImage(ii, im.x*width, im.y*height, im.w*width, im.h*height);
    }
    for(const tx of (ann.texts||[])){
      const fontSz = tx.fontSize || 16;
      tctx.font = `${fontSz}px ${tx.fontFamily || 'Arial'}`;
      const textContent = (tx.html||'').replace(/<[^>]+>/g,'') || ' ';
      tctx.fillStyle = tx.color || '#ffffff';
      tctx.fillText(textContent, tx.x*width + 4, tx.y*height + fontSz + 4);
    }
    const png = tmp.toDataURL('image/png');
    const pngBytes = await (await fetch(png)).arrayBuffer();
    const embedded = await outPdf.embedPng(pngBytes);
    page.drawImage(embedded, {x:0,y:0,width,height});
  }
  return outPdf.save();
}

// init + responsive
(function init(){
  setMode('draw');
})();
let resizeTimer=null;
window.addEventListener('resize', ()=>{ if(!pdfDoc) return; clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>renderPage(currentPage),200); });

function setMode(m){
  mode = m;
  if(m==='text'){ annotCanvas.style.pointerEvents='none'; annotLayer.style.pointerEvents='auto'; }
  else { annotCanvas.style.pointerEvents='auto'; annotLayer.style.pointerEvents='none'; }
}
</script>
</body>
</html>
